// Code generated by protoc-gen-go. DO NOT EDIT.
// source: spire/server/identityexchanger/identityexchanger.proto

package indentityexchanger

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	common "github.com/spiffe/spire/proto/spire/common"
	plugin "github.com/spiffe/spire/proto/spire/common/plugin"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Represents a request to identify an agentless workload.
type ExchangeRequest struct {
	// Types that are valid to be assigned to Step:
	//	*ExchangeRequest_Data
	//	*ExchangeRequest_Response
	Step                 isExchangeRequest_Step `protobuf_oneof:"step"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *ExchangeRequest) Reset()         { *m = ExchangeRequest{} }
func (m *ExchangeRequest) String() string { return proto.CompactTextString(m) }
func (*ExchangeRequest) ProtoMessage()    {}
func (*ExchangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6889fb4d90fed7f, []int{0}
}

func (m *ExchangeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExchangeRequest.Unmarshal(m, b)
}
func (m *ExchangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExchangeRequest.Marshal(b, m, deterministic)
}
func (m *ExchangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeRequest.Merge(m, src)
}
func (m *ExchangeRequest) XXX_Size() int {
	return xxx_messageInfo_ExchangeRequest.Size(m)
}
func (m *ExchangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeRequest proto.InternalMessageInfo

type isExchangeRequest_Step interface {
	isExchangeRequest_Step()
}

type ExchangeRequest_Data struct {
	Data *ExchangeData `protobuf:"bytes,1,opt,name=data,proto3,oneof"`
}

type ExchangeRequest_Response struct {
	Response []byte `protobuf:"bytes,2,opt,name=response,proto3,oneof"`
}

func (*ExchangeRequest_Data) isExchangeRequest_Step() {}

func (*ExchangeRequest_Response) isExchangeRequest_Step() {}

func (m *ExchangeRequest) GetStep() isExchangeRequest_Step {
	if m != nil {
		return m.Step
	}
	return nil
}

func (m *ExchangeRequest) GetData() *ExchangeData {
	if x, ok := m.GetStep().(*ExchangeRequest_Data); ok {
		return x.Data
	}
	return nil
}

func (m *ExchangeRequest) GetResponse() []byte {
	if x, ok := m.GetStep().(*ExchangeRequest_Response); ok {
		return x.Response
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ExchangeRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ExchangeRequest_Data)(nil),
		(*ExchangeRequest_Response)(nil),
	}
}

// Represents a response when identifying caller
type ExchangeResponse struct {
	// Types that are valid to be assigned to Step:
	//	*ExchangeResponse_Challenge
	//	*ExchangeResponse_Response_
	Step                 isExchangeResponse_Step `protobuf_oneof:"step"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ExchangeResponse) Reset()         { *m = ExchangeResponse{} }
func (m *ExchangeResponse) String() string { return proto.CompactTextString(m) }
func (*ExchangeResponse) ProtoMessage()    {}
func (*ExchangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6889fb4d90fed7f, []int{1}
}

func (m *ExchangeResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExchangeResponse.Unmarshal(m, b)
}
func (m *ExchangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExchangeResponse.Marshal(b, m, deterministic)
}
func (m *ExchangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeResponse.Merge(m, src)
}
func (m *ExchangeResponse) XXX_Size() int {
	return xxx_messageInfo_ExchangeResponse.Size(m)
}
func (m *ExchangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeResponse proto.InternalMessageInfo

type isExchangeResponse_Step interface {
	isExchangeResponse_Step()
}

type ExchangeResponse_Challenge struct {
	Challenge []byte `protobuf:"bytes,1,opt,name=challenge,proto3,oneof"`
}

type ExchangeResponse_Response_ struct {
	Response *ExchangeResponse_Response `protobuf:"bytes,2,opt,name=response,proto3,oneof"`
}

func (*ExchangeResponse_Challenge) isExchangeResponse_Step() {}

func (*ExchangeResponse_Response_) isExchangeResponse_Step() {}

func (m *ExchangeResponse) GetStep() isExchangeResponse_Step {
	if m != nil {
		return m.Step
	}
	return nil
}

func (m *ExchangeResponse) GetChallenge() []byte {
	if x, ok := m.GetStep().(*ExchangeResponse_Challenge); ok {
		return x.Challenge
	}
	return nil
}

func (m *ExchangeResponse) GetResponse() *ExchangeResponse_Response {
	if x, ok := m.GetStep().(*ExchangeResponse_Response_); ok {
		return x.Response
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ExchangeResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ExchangeResponse_Challenge)(nil),
		(*ExchangeResponse_Response_)(nil),
	}
}

// Success response, that contains selectors and spiffeID extracted from presented data
type ExchangeResponse_Response struct {
	// Worklaod SPIFFE ID
	WorkloadId string `protobuf:"bytes,1,opt,name=workload_id,json=workloadId,proto3" json:"workload_id,omitempty"`
	// List of selectors
	Selectors            []*common.Selector `protobuf:"bytes,2,rep,name=selectors,proto3" json:"selectors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ExchangeResponse_Response) Reset()         { *m = ExchangeResponse_Response{} }
func (m *ExchangeResponse_Response) String() string { return proto.CompactTextString(m) }
func (*ExchangeResponse_Response) ProtoMessage()    {}
func (*ExchangeResponse_Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6889fb4d90fed7f, []int{1, 0}
}

func (m *ExchangeResponse_Response) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExchangeResponse_Response.Unmarshal(m, b)
}
func (m *ExchangeResponse_Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExchangeResponse_Response.Marshal(b, m, deterministic)
}
func (m *ExchangeResponse_Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeResponse_Response.Merge(m, src)
}
func (m *ExchangeResponse_Response) XXX_Size() int {
	return xxx_messageInfo_ExchangeResponse_Response.Size(m)
}
func (m *ExchangeResponse_Response) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeResponse_Response.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeResponse_Response proto.InternalMessageInfo

func (m *ExchangeResponse_Response) GetWorkloadId() string {
	if m != nil {
		return m.WorkloadId
	}
	return ""
}

func (m *ExchangeResponse_Response) GetSelectors() []*common.Selector {
	if m != nil {
		return m.Selectors
	}
	return nil
}

// TODO: MOVE TO COMMON, Is it really required to move outside?
type ExchangeData struct {
	//* Type of exchange to perform.
	Type string `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	//* The exchange data.
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExchangeData) Reset()         { *m = ExchangeData{} }
func (m *ExchangeData) String() string { return proto.CompactTextString(m) }
func (*ExchangeData) ProtoMessage()    {}
func (*ExchangeData) Descriptor() ([]byte, []int) {
	return fileDescriptor_c6889fb4d90fed7f, []int{2}
}

func (m *ExchangeData) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExchangeData.Unmarshal(m, b)
}
func (m *ExchangeData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExchangeData.Marshal(b, m, deterministic)
}
func (m *ExchangeData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeData.Merge(m, src)
}
func (m *ExchangeData) XXX_Size() int {
	return xxx_messageInfo_ExchangeData.Size(m)
}
func (m *ExchangeData) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeData.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeData proto.InternalMessageInfo

func (m *ExchangeData) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ExchangeData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterType((*ExchangeRequest)(nil), "spire.server.indentityexchanger.ExchangeRequest")
	proto.RegisterType((*ExchangeResponse)(nil), "spire.server.indentityexchanger.ExchangeResponse")
	proto.RegisterType((*ExchangeResponse_Response)(nil), "spire.server.indentityexchanger.ExchangeResponse.Response")
	proto.RegisterType((*ExchangeData)(nil), "spire.server.indentityexchanger.ExchangeData")
}

func init() {
	proto.RegisterFile("spire/server/identityexchanger/identityexchanger.proto", fileDescriptor_c6889fb4d90fed7f)
}

var fileDescriptor_c6889fb4d90fed7f = []byte{
	// 422 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0x5d, 0x6b, 0xd4, 0x40,
	0x14, 0x6d, 0xd6, 0xa5, 0xec, 0xde, 0x54, 0xd4, 0x79, 0x90, 0x35, 0x88, 0x0d, 0x05, 0x25, 0x0a,
	0x26, 0x35, 0x4a, 0x1f, 0x04, 0x11, 0xac, 0x62, 0xf7, 0x4d, 0xe2, 0x8b, 0xf4, 0x45, 0xa6, 0xc9,
	0x4d, 0x76, 0x30, 0x9d, 0x89, 0x33, 0x13, 0xb5, 0xe0, 0x4f, 0xf4, 0xff, 0xf8, 0x2a, 0x3b, 0x1f,
	0xd9, 0xa6, 0x16, 0xda, 0x3e, 0x65, 0x72, 0xef, 0x39, 0xf7, 0x9c, 0x39, 0x33, 0x03, 0x07, 0xaa,
	0x63, 0x12, 0x33, 0x85, 0xf2, 0x07, 0xca, 0x8c, 0x55, 0xc8, 0x35, 0xd3, 0x67, 0xf8, 0xab, 0x5c,
	0x51, 0xde, 0x5c, 0x56, 0x49, 0x3b, 0x29, 0xb4, 0x20, 0xbb, 0x86, 0x97, 0x5a, 0x5e, 0xca, 0xf8,
	0x45, 0x58, 0x14, 0xdb, 0xc1, 0xa5, 0x38, 0x3d, 0x15, 0x3c, 0xeb, 0xda, 0xbe, 0x61, 0xfe, 0x63,
	0x47, 0x44, 0x0f, 0x46, 0x08, 0xfb, 0xb1, 0xad, 0xbd, 0xdf, 0x70, 0xe7, 0x83, 0x9b, 0x54, 0xe0,
	0xf7, 0x1e, 0x95, 0x26, 0x87, 0x30, 0xad, 0xa8, 0xa6, 0x8b, 0x20, 0x0e, 0x92, 0x30, 0x7f, 0x9e,
	0x5e, 0xa1, 0x9f, 0x7a, 0xfe, 0x7b, 0xaa, 0xe9, 0xd1, 0x56, 0x61, 0xc8, 0xe4, 0x21, 0xcc, 0x24,
	0xaa, 0x4e, 0x70, 0x85, 0x8b, 0x49, 0x1c, 0x24, 0x3b, 0x47, 0x5b, 0xc5, 0x50, 0x79, 0xb7, 0x0d,
	0x53, 0xa5, 0xb1, 0xdb, 0xfb, 0x1b, 0xc0, 0xdd, 0x8d, 0xbc, 0x6d, 0x92, 0x47, 0x30, 0x2f, 0x57,
	0xb4, 0x6d, 0x91, 0x37, 0x68, 0x4c, 0xac, 0xb9, 0x9b, 0x12, 0xf9, 0x72, 0x61, 0x74, 0x98, 0xbf,
	0xbe, 0xb6, 0x47, 0x2f, 0x92, 0xfa, 0xc5, 0x79, 0x5b, 0x11, 0x85, 0xd9, 0xe0, 0x62, 0x17, 0xc2,
	0x9f, 0x42, 0x7e, 0x6b, 0x05, 0xad, 0xbe, 0xb2, 0xca, 0xf8, 0x98, 0x17, 0xe0, 0x4b, 0xcb, 0x8a,
	0xbc, 0x82, 0xb9, 0xc2, 0x16, 0x4b, 0x2d, 0xa4, 0x5a, 0x4c, 0xe2, 0x5b, 0x49, 0x98, 0xdf, 0x77,
	0x3e, 0x5c, 0xc2, 0x9f, 0x5d, 0xbb, 0xd8, 0x00, 0x87, 0x9d, 0x1f, 0xc0, 0xce, 0xf9, 0xdc, 0x08,
	0x81, 0xa9, 0x3e, 0xeb, 0xd0, 0xe9, 0x98, 0xf5, 0xba, 0x66, 0x0e, 0xc2, 0xe4, 0x67, 0x73, 0xcd,
	0xff, 0x4c, 0xe0, 0xde, 0xd2, 0x6d, 0xcf, 0x0f, 0x90, 0x44, 0xc1, 0xcc, 0xff, 0x90, 0xfd, 0x1b,
	0x84, 0x61, 0x0e, 0x3c, 0x7a, 0x71, 0xe3, 0xf8, 0x92, 0x60, 0x3f, 0x20, 0xc7, 0x30, 0x3f, 0x14,
	0xbc, 0x66, 0x4d, 0x2f, 0x91, 0x3c, 0x1e, 0x6f, 0xdd, 0x5d, 0xbf, 0xa1, 0xef, 0xa5, 0x9e, 0x5c,
	0x05, 0x73, 0xe9, 0xd7, 0x70, 0xfb, 0x23, 0xea, 0x4f, 0xa6, 0xbd, 0xe4, 0xb5, 0x20, 0x4f, 0x2f,
	0x25, 0x8e, 0x30, 0x5e, 0xe3, 0xd9, 0x75, 0xa0, 0xee, 0x22, 0xbe, 0x3d, 0x7e, 0xd3, 0x30, 0xbd,
	0xea, 0x4f, 0xd6, 0xe8, 0x4c, 0x75, 0xac, 0xae, 0x31, 0xb3, 0xaf, 0xc5, 0xbc, 0x8f, 0x6c, 0xfc,
	0x68, 0xff, 0x4b, 0xe6, 0x64, 0xdb, 0xc0, 0x5e, 0xfe, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x88, 0xf2,
	0xd0, 0xcc, 0xde, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// IdentityExchangerClient is the client API for IdentityExchanger service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type IdentityExchangerClient interface {
	// Exchange SVID,
	Exchange(ctx context.Context, opts ...grpc.CallOption) (IdentityExchanger_ExchangeClient, error)
	//* Responsible for configuration of the plugin.
	Configure(ctx context.Context, in *plugin.ConfigureRequest, opts ...grpc.CallOption) (*plugin.ConfigureResponse, error)
	//* Returns the  version and related metadata of the installed plugin.
	GetPluginInfo(ctx context.Context, in *plugin.GetPluginInfoRequest, opts ...grpc.CallOption) (*plugin.GetPluginInfoResponse, error)
}

type identityExchangerClient struct {
	cc grpc.ClientConnInterface
}

func NewIdentityExchangerClient(cc grpc.ClientConnInterface) IdentityExchangerClient {
	return &identityExchangerClient{cc}
}

func (c *identityExchangerClient) Exchange(ctx context.Context, opts ...grpc.CallOption) (IdentityExchanger_ExchangeClient, error) {
	stream, err := c.cc.NewStream(ctx, &_IdentityExchanger_serviceDesc.Streams[0], "/spire.server.indentityexchanger.IdentityExchanger/Exchange", opts...)
	if err != nil {
		return nil, err
	}
	x := &identityExchangerExchangeClient{stream}
	return x, nil
}

type IdentityExchanger_ExchangeClient interface {
	Send(*ExchangeRequest) error
	Recv() (*ExchangeResponse, error)
	grpc.ClientStream
}

type identityExchangerExchangeClient struct {
	grpc.ClientStream
}

func (x *identityExchangerExchangeClient) Send(m *ExchangeRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *identityExchangerExchangeClient) Recv() (*ExchangeResponse, error) {
	m := new(ExchangeResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *identityExchangerClient) Configure(ctx context.Context, in *plugin.ConfigureRequest, opts ...grpc.CallOption) (*plugin.ConfigureResponse, error) {
	out := new(plugin.ConfigureResponse)
	err := c.cc.Invoke(ctx, "/spire.server.indentityexchanger.IdentityExchanger/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *identityExchangerClient) GetPluginInfo(ctx context.Context, in *plugin.GetPluginInfoRequest, opts ...grpc.CallOption) (*plugin.GetPluginInfoResponse, error) {
	out := new(plugin.GetPluginInfoResponse)
	err := c.cc.Invoke(ctx, "/spire.server.indentityexchanger.IdentityExchanger/GetPluginInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// IdentityExchangerServer is the server API for IdentityExchanger service.
type IdentityExchangerServer interface {
	// Exchange SVID,
	Exchange(IdentityExchanger_ExchangeServer) error
	//* Responsible for configuration of the plugin.
	Configure(context.Context, *plugin.ConfigureRequest) (*plugin.ConfigureResponse, error)
	//* Returns the  version and related metadata of the installed plugin.
	GetPluginInfo(context.Context, *plugin.GetPluginInfoRequest) (*plugin.GetPluginInfoResponse, error)
}

// UnimplementedIdentityExchangerServer can be embedded to have forward compatible implementations.
type UnimplementedIdentityExchangerServer struct {
}

func (*UnimplementedIdentityExchangerServer) Exchange(srv IdentityExchanger_ExchangeServer) error {
	return status.Errorf(codes.Unimplemented, "method Exchange not implemented")
}
func (*UnimplementedIdentityExchangerServer) Configure(ctx context.Context, req *plugin.ConfigureRequest) (*plugin.ConfigureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (*UnimplementedIdentityExchangerServer) GetPluginInfo(ctx context.Context, req *plugin.GetPluginInfoRequest) (*plugin.GetPluginInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPluginInfo not implemented")
}

func RegisterIdentityExchangerServer(s *grpc.Server, srv IdentityExchangerServer) {
	s.RegisterService(&_IdentityExchanger_serviceDesc, srv)
}

func _IdentityExchanger_Exchange_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(IdentityExchangerServer).Exchange(&identityExchangerExchangeServer{stream})
}

type IdentityExchanger_ExchangeServer interface {
	Send(*ExchangeResponse) error
	Recv() (*ExchangeRequest, error)
	grpc.ServerStream
}

type identityExchangerExchangeServer struct {
	grpc.ServerStream
}

func (x *identityExchangerExchangeServer) Send(m *ExchangeResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *identityExchangerExchangeServer) Recv() (*ExchangeRequest, error) {
	m := new(ExchangeRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _IdentityExchanger_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(plugin.ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityExchangerServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.server.indentityexchanger.IdentityExchanger/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityExchangerServer).Configure(ctx, req.(*plugin.ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _IdentityExchanger_GetPluginInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(plugin.GetPluginInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(IdentityExchangerServer).GetPluginInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.server.indentityexchanger.IdentityExchanger/GetPluginInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(IdentityExchangerServer).GetPluginInfo(ctx, req.(*plugin.GetPluginInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _IdentityExchanger_serviceDesc = grpc.ServiceDesc{
	ServiceName: "spire.server.indentityexchanger.IdentityExchanger",
	HandlerType: (*IdentityExchangerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Configure",
			Handler:    _IdentityExchanger_Configure_Handler,
		},
		{
			MethodName: "GetPluginInfo",
			Handler:    _IdentityExchanger_GetPluginInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Exchange",
			Handler:       _IdentityExchanger_Exchange_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "spire/server/identityexchanger/identityexchanger.proto",
}
